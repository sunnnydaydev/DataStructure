为什么要有树结构：
树结构本身是一种天然的组织结构   ------   文件夹结构、  公司职务  （ 源于生活）

使用树 ：高效


树： 1 二叉树

     2 多叉树

一、  二叉树



二叉树：和链表一样，动态数据结构     每个结点最多有两个子树的树结构。

性质：
     1 根节点 唯一
     2 每个节点最多有两个孩子
     3 每个节点最多只有一个父亲节点


     叶子节点： 一个孩子也没有  （节点的左右孩子都为空）


     二叉树也就有天然的递归结构：
        每个节点的左孩子可以看成一个二叉树的根节点 成为左子树
        每个节点的右孩子可以看成一个二叉树的根节点 成为右子树


 满二叉树：对于每个节点来说，除了叶子节点外，都有两个孩子，所以二叉树不一定是满的。

 注意：一个节点也可以看做二叉树   左右节点都为空，满足节点的定义就行。


 二 、  二分搜索树（二叉排序树 二叉查找树，二叉搜索树）

    二分搜索树是一个二叉树，具备二叉树的所有性质。

    二分搜索树的独特性质：
         1 每个节点的值：
             大于其左子树所有节点的值
             小于其右子树所有节点的值
             （大于左边的所有节点，小于右面的所有节点）
         2 每颗子树也是二分搜索树

    优点：大大加快了查询速度（给了数值就知道沿着那个方向查）
         参考生活实例，图书馆寻找特定书。去那个方向找xxx就行了


    要求：存储的元素要有可比较性（自定义对象要能比较）

    可以看作：二分搜索树的局限性


    二分搜索树的 ：
                1 类设计
                2 插入操作 ：思路从根节点开始比较，大于插入右子树，小于插入左子树
                            （寻找到子树的下一节点为null插入此位置）


  注意   插入特例：重复的元素  我们设计了不重复的元素，如果想插入重复的元素，则可以设计
              其中的任意节点，其左子树小于等于这个节点值，其右子树大于。
                              其左子树小于这个节点值，其右子树大于等于。即可
         我们可以自己定义实现，此处不实现

         原则上是没有重复元素的


         插入的操作，使用非递归方式，进行比较就行了。
            插入总结：a 判断根节点是否为空
                      b  递归插入（左面或者右面）


         3 查询操作
             查询总结：
             a 节点判空？
             b 是否含有？
             c 递归找（左右情况）
         4  遍历 （访问节点的顺序）
              前序遍历：先访问跟节点，再访问左右子树。，再访问右子树  最自热最常用的方式(打印数据从根开始)
              中序遍历：先访问左孩子，在访问根节点，最后访问右节点（打印数据从叶子开始）
                        二分搜索树中序遍历使数据按照从小到大排列（因此二分搜索树又叫二分排序树）
              后序遍历: 对当前节点的遍历在对左右孩子节点的遍历之后, 遍历顺序 : 左孩子->右孩子->当前节点
                         后续遍历的应用场景：内存释放，先释放孩子，在释放父亲（c++中）
             ps:根据节点的访问前后顺序 为 前中后 遍历     前序后续没规律，中序 有


               遍历分类：
                     深度优先遍历：从一个节点分支开始往下遍历，便利到不能再遍历（前中后顺遍历）
                     广度优先遍历：又叫做层序遍历，自上而下一层一层遍历。（通常非递归实现）


层序遍历（广度优先遍历）：队列实现 ，队列的应用

深度优先遍历：（非递归实现）前序遍历，栈的应用

广度优先遍历优点：更快找到问题，常用与最短路径（）

图：也有深度广度优先遍历

            5 二分搜索的的删除


