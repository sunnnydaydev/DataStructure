一 、优先队列：

   普通队列：先进先出，后进后出。
   优先队列：出队顺序和入队顺序无关，和优先级有关。

   举例：操作系统的任务调度，游戏的自动攻击敌人

   特点：动态的选择优先级最高的执行

   关键词：动态 不断变化



   接口设计：
       E dequeue();
       E getFront();
       int getSize();
       void enqueue(E e);
       boolean isEmpty();

       和队列类似只是：
        E dequeue(); 出队出优先级最高的
        E getFront(); 查看队首元素 查看优先级最高的。

        实现方式：

        1 普通线性结构 （数组 或者链表）
           入队o（1）
           出队o（n） 元素扫描一遍，找出优先级最高的。

         2 使用顺序线性结构 可以解决出队问题 使出队o（1），取出队首或者队尾即可。
           但是入队要找合适位置 最差情况下o（n）
           // TODO 这两种都含有O（n）的复杂度，以后我们自己实现。
         3 使用堆实现 （高效O（logn））

二 、堆
      满二叉树（除了孩子节点其他的节点左右孩子都不为空）
      使用二叉树表示堆--------二叉堆。

     满足特殊性质的二叉树叫做二叉堆。
     满足性质：
     1 二叉堆是一个完全二叉树
          完全二叉树，吧元素顺序排成树的形状，最后一层从左往右排即可 （整个树的右下有可能是空）
          - 若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。
     2 堆中每个节点的值总是不大于其父亲节点的值（根节点是最大的元素）
     3 堆中每个节点的值总是小于等于其孩子节点的值，根节点为最小元素）

     1 是必备 2,3任选。

     1  2  为：最大堆
     2  3  为：最小堆

     使用数组表示二叉堆:

     二叉堆 层次上从上到下，水平上从左到右 编号就形成数组索引。



     1 添加元素：只能添加到末尾，在进行条件判断
     sift up

     2 取出元素： 只能取出根节点（最大堆中的最大值）
     sift down
      吧首元素 取出，为了保持形状吧末尾元素顶替，然后 吧新的根元素下沉比较(和孩子中最大的交换)。

      3 repalce 替换元素（替换最大元素：取出最大 放入新的替代）
       使用上面的组合可完成 取出最大元素，添加末尾   两次 o(logn) 操作

       思路：直接将堆顶替换，然后执行sift down

       4 Heapify  将任意数组整理成堆的形状
        思路一： 将数组遍历，逐个元素添加到堆中就行

        补充： 完全二叉树 最后一个非叶子节点 对应的索引表示
               首先计算最后一个元素索引，在计算他的父亲节点就行了。
        思路二：最后一个非叶子节点开始逐个向前siftdown  就可满足堆的性质了
         （优点：抛弃叶子节点只操作父亲节点，相对add操作元素少了一半）


         三 、 优先队列   属于队列  （复用接口）
        1  使用线性数据结构实现
        2 堆的实现


        四 拓展
            本文是 二叉堆
            拓展 d 叉堆   节点有d个孩子

            索引堆 （本文只能看到首个元素 最大元素）
