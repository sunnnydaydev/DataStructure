# HashTab基础

###### 啥是哈希函数？

数组的查询、修改时间复杂度为O(1),若是物体之间存在映射关系，则可以借鉴数组的优势把“键”转化为数组的索引这就是哈希函数要做的事情。

###### 从生活中的“键”转化为索引引起的思考

假如一个班级有30名学生，学号为1-30，这时可以以学号减一作为数组的索引即可顺利存储30名学生的信息，这样的从“键”转化为索引的方式还是相对简单的。

不过大多数情况下我们处理的数据都比较复杂，如我们对居民的信息感兴趣，居民的唯一识别标识可能是身份证号（18位的数字）由于身份证的数字太大了超出了整数的范围我们不能直接使用这个数字作为数组的索引，实际上这也是一个很大的数字就算使用这个作为数组的索引那需要申请的空间极大，且17位及其以下的能存不使用都造成了浪费。

更有甚者，某些唯一标识和数字都没有啥直接关系，最常见的就是字符串喽。还是以学生的信息为栗子假如就以学生的姓名为键来标识学生的信息。这时这个“键”就是一个字符串，此时如何设计一个哈希函数将字符串转化为数字？这就是设计哈希表时需要我们考虑的首个问题~

上述中以学生学号为索引设计出的哈希函数索引唯一，索引数字范围足够小非常方便使用数组做存储；但是更多的数据类型如字符串、日期、浮点数等我们很难的保证每一个“键”通过我们设计的哈希函数的转化对应不同的索引。也就是说两个不同的键通过我们设计的哈希函数转化后产生了相同的索引，我们称之为“哈希冲突”这也是我们需要解决的第二个问题~

###### 时间与空间

Hash表充分体现出了算法设计领域的经典思想：以空间换时间。上述身份证的栗子，假如我们能够申请18个9的这样的很大的空间，那么对用户的信息查询时间复杂度就是O(1)。在假设一种极端情况，我们只能申请1个数组空间，那么所有的数据转化为索引时都会产生哈希冲突，这时假如我们使用链表这种数据结构来存储数据那么查询也是个O(n)的时间复杂度。

上述就是两种极端的情况，一个是空间极大这时时间消耗很小，一个是空间很小占用时间比较大，而哈希表则是时间与空间的平衡~

# Hash函数的设计

哈希函数的设计基准原则：

- 一致性：如果a==b那么hash(a)==hash(b)
- 高效性：计算高效简便。
- 均匀性：获取的索引分布约均匀越好



那么如何设计哈希函数呢？这个要根据具体问题具体分析，因为hash函数的设计在很多特殊的领域有很多特殊的做法。这里就以整数为索引设计函数：

- 小范围正整数：直接使用
- 小范围负整数：范围偏移
- 大范围整数：常见的做法是取模取余法。取模一个素数有利于解决索引的分布不均匀、更好利用原数据信息。这背后是由大量数学理论验证的我们可以不必深挖，但是可以以栗子验证其均匀性，哈希冲突概率小：

| 一组数字 | 非素数选4 | 素数选7 |
| :------: | :-------: | :-----: |
|    10    |     2     |    3    |
|    20    |     0     |    6    |
|    30    |     2     |    2    |
|    40    |     0     |    4    |
|    50    |     2     |    1    |

素数的选择有相应的研究人员会研究提供。

- 字符串：转为整型处理。如可以看做26进制的大整形数。

  ![1651757934656](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1651757934656.png)

# Java中的HashCode

- 已有的类：直接通过hashCode方法获取。
- 自定义类：也可重写hashCode方法获取。

###### hashCode设计的思想

只提供目标键到数字的转换，至于索引的获取是hash表的范畴。哈希表中自己设计获取。

# HashTab的实现

首先思考下如何设计HashTab，我们需要解决两个问题：

1、hash 函数的设计

这里可以通过java的hashCode方法得一个hash值，不过这个值可能为负数，需要我们手动处理，这时结合数组的容量即可设计出HashTab中的hash值。具体做法是对

- 首先通过java的hashCode方法得到一个hash值。
- 其次对hash值进行非负处理（java的hashCode方法返回一个整数可能为负）
- 最后对结果进行取模得到均匀分布的数值

2、hash冲突的解决

取模运算即使素数选择的再好也会有hash冲突的case，这时需要解决hash冲突，最常用的解决方案就是链表地址法。



链表地址法原理图解

- HashMap中Java8之前每个位置对应的就是一个链表，但是Java8开始，当Hash冲突到达一定的程度后链表就会转化为红黑树。

- TreeMap底层就是红黑树实现

